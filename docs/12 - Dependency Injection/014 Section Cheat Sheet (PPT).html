<h4>Services</h4><figure><img height="339" src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-43-fc30b8ecf4b61e73b6c423bb950ff066.png" width="791"></figure><p>'Service' is a class that contains business logic such as business calculations, business validations that are specific to the domain of the client's business.</p><p>Service is an abstraction layer (middle layer) between presentation layer (or application layer) and data layer.</p><p>It makes the business logic separated from presentation layer and data layer.</p><p>It makes the business logic to be unit testable easily.</p><p>Will be invoked by controller.</p><p><br></p><h4></h4><h4>Direct Dependency</h4><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-43-743737a1df4184a1e520478c3686a93a.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-44-f25d9069cb756fb8cf9a5ab944d23dfb.png"></figure><p>Higher-level modules depend on lower-level modules.</p><p><br></p><p><br></p><h4>Dependency Problem</h4><blockquote><p>Higher-level modules depend on lower-level modules.</p></blockquote><ul><li><p>Means, both are tightly-coupled.</p></li><li><p>The developer of higher-level module SHOULD WAIT until the completion of development of lower-level module.</p></li><li><p>Requires much code changes in to interchange an alternative lower-level module.</p></li><li><p>Any changes made in the lower-level module effects changes in the higher-level module.</p></li><li><p>Difficult to test a single module without effecting / testing the other module.</p></li></ul><p><br></p><h4>Dependency Inversion Principle</h4><p>Dependency Inversion Principle (DIP) is a design principle (guideline), which is a solution for the dependency problem.</p><p><br></p><blockquote><p>"The higher-level modules (clients) SHOULD NOT depend on low-level modules (dependencies).</p><p>Both should depend on abstractions (interfaces or abstract class)."</p><p>"Abstractions should not depend on details (both client and dependency).</p><p>Details (both client and dependency) should depend on abstractions."</p></blockquote><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-44-272bcf8a979e69cfee73fc78543dee44.png"></figure><p><br></p><p>The interface is controlled by the client.</p><p>Both client and dependency depend on abstraction.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-44-3fab5f769c22f48fc3de6dd5d357b271.png"></figure><p><br></p><p><br></p><h4>Inversion of Control (IoC)</h4><ul><li><p>Inversion of Control (IoC) is a design pattern (reusable solution for a common problem), which suggests "IoC container" for implementation of Dependency Inversion Principle (DIP).</p></li><li><p>It inverses the control by shifting the control to IoC container.</p></li><li><p>"Don't call us, we will call you" pattern.</p></li><li><p>It can be implemented by other design patterns such as events, service locator, dependency injection etc.</p></li></ul><p><br></p><figure><img height="324" src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-20_14-55-44-c4f7c15083611b74805a7e2c144e3f8a.png" width="764"></figure><p><br></p><p>All dependencies should be added into the IServiceCollection (acts as IoC container).</p><pre class="prettyprint linenums">builder.Services.Add(
  new ServiceDescriptor(
    typeof (Interface),
    typeof (Service)
    ServiceLifetime.LifeTime //Transient, Scoped, Singleton
  )
);
</pre><p><br></p><p><br></p><h4>Dependency Injection (DI)</h4><ul><li><p>Dependency injection (DI) is a design pattern, which is a technique for achieving "Inversion of Control (IoC)" between clients and their dependencies.</p></li><li><p>It allows you to inject (supply) a concrete implementation object of a low-level component into a high-level component.</p></li><li><p>The client class receives the dependency object as a parameter either in the constructor or in a method.</p></li></ul><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-24-06b2b809acfcb65b1bc6eeac7c25c4aa.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-24-38342e13fe7b89d97fb3e79e3fdea36e.png"></figure><p><br></p><p><br></p><h4>Method Injection</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-76384d6772c9aa48b34cf3c0947eb831.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-8652f071c7674b29f0cec1dbdd626f65.png"></figure><p><br></p><p><br></p><p><br></p><h4>Service Lifetime</h4><p>(Transient, Scoped, Singleton)</p><p><br></p><p>A service lifetime indicates when a new object of the service has to be created by the IoC / DI container.</p><ol><li><p><strong>Transient: </strong>Per injection</p></li><li><p><strong>Scoped: </strong>Per scope (browser request)</p></li><li><p><strong>Singleton: </strong>For entire application lifetime.</p></li></ol><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-39929b4394d951991197a978f089d8c2.png"></figure><p><br></p><p><strong>Transient</strong></p><p>Transient lifetime service objects are created each time when they are injected.</p><p>Service instances are disposed at the end of the scope (usually, a browser request)</p><p><br></p><p><strong>Scoped</strong></p><p>Scoped lifetime service objects are created once per a scope (usually, a browser request).</p><p>Service instances are disposed at the end of the scope (usually, a browser request).</p><p><br></p><p><strong>Singleton</strong></p><p>Singleton lifetime service objects are created for the first time when the are requested.</p><p>Service instances are disposed at application shutdown.</p><p><br></p><p><br></p><p><strong>Transient</strong></p><p><code>builder.Services.AddTransient&lt;IService, Service&gt;(); //Transient Service</code></p><p><strong>Scoped</strong></p><p><code>builder.Services.AddScoped&lt;IService, Service&gt;(); //Scoped Service</code></p><p><strong>Singleton</strong></p><p><code>builder.Services.AddSingleton&lt;IService, Service&gt;(); //Singleton Service</code></p><p><br></p><p><br></p><h4>Service Scope</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-9cebeecaf0f1e4d8a3e85c7626e6b61f.png"></figure><p><br></p><p><br></p><p><br></p><h4>View Injection</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-92d6cd2801ca0a4193a8c368792ddbbe.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-bdb2843c5a04c2aa94e6d35dea65f53e.png"></figure><p><br></p><p><br></p><h4>Best Practices in DI</h4><p><br></p><blockquote><p><strong>Global state in services</strong></p><p>Avoid using&nbsp;<strong>static classes&nbsp;</strong>to store some data globally for all users / all requests.</p><p>You may use&nbsp;<strong>Singleton</strong>&nbsp;services for simple scenarios / simple amount of data. In this case, prefer ConcurrentDictionary instead of Dictionary, which better handles concurrent access via multiple threads.</p><p>Alternatively, prefer to use&nbsp;<strong>Distributed Cache / Redis</strong>&nbsp;for any significant amount of data or complex scenarios.</p></blockquote><p><br></p><blockquote><p><strong>Request state in services</strong></p><p>Don't use scoped services to share data among services within the same request, because they are NOT thread-safe.</p><p>Use&nbsp;<strong>HttpContext.Items&nbsp;</strong>instead.</p></blockquote><p><br></p><blockquote><p><strong>Service Locator Pattern</strong></p><p>Avoid using service locator pattern, without creating a child scope, because it will be harder to know about dependencies of a class.</p><p>For example, don't invoke&nbsp;<strong>GetService()</strong>&nbsp;in the default scope that is created when a new request is received.</p><p>But you can use the&nbsp;<strong>IServiceScopeFactory.ServiceProvider. GetService()</strong>&nbsp;within a child scope.</p></blockquote><p><br></p><blockquote><p><strong>Calling Dispose() method</strong></p><p>Don't invoke the Dispose() method manually for the services injected via DI.</p><p>The IoC container automatically invoke Dispose(), at the end of its scope.</p></blockquote><p><br></p><blockquote><p><strong>Captive Dependencies</strong></p><p>Don't inject scoped or transient services in singleton services.</p><p>Because, in this case, transient or scoped services act as singleton services, inside of singleton service.</p></blockquote><p><br></p><blockquote><p><strong>Storing reference of service instance</strong></p><p>Don't hold the reference of a resolved service object.</p><p>It may cause memory leaks and you may have access to a disposed service object.</p></blockquote><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-46-25-e0066f0a9e984821ba9b6ed473bab5ea.png"></figure><p><br></p><h4>Autofac</h4><ul><li><p>Autofac is another IoC container library for .Net Core.</p></li><li><p>Means, both are tightly-coupled.</p></li><li><p>Microsoft.Extensions.DependencyInjection [vs] Autofac</p></li><li><p>https://autofac.readthedocs.io/en/latest/getting-started/index.html</p></li></ul><p><br></p><p><strong>Microsoft.Extensions.DependencyInjection</strong></p><ul><li><p>Built-in IoC container in asp.net core</p></li><li><p>Lifetimes: Transient, Scoped, Singleton</p></li><li><p>Metadata for services: Not supported</p></li><li><p>Decorators: Not supported</p></li></ul><p><br></p><p><strong>Autofac</strong></p><ul><li><p>Alternative to the Microsoft.Extensions</p></li><li><p>Lifetimes: InstancePerDependency, InstancePerLifetimeScope, SingleInstance, InstancePerOwned, InstancePerMatchingLifetimeScope</p></li><li><p>Metadata for services: Supported</p></li><li><p>Decorators: Supported</p></li></ul><p><br></p>