<h4>Overview of SOLID Principles</h4><p>"SOLID" is a set of five design patterns, whose main focus is to create loosely coupled, flexible, maintainabile code.</p><p>Broad goal of SOLID Principles:Reduce dependencies of various classes / modules of the application.</p><p><br></p><p><strong>Single Responsibility Principle (SRP)</strong></p><p>A software module or class should have one-and-only reason to change.</p><p><br></p><p><strong>Liskov Subsitution Principle (LSP)</strong></p><p>Subtypes must be substitutable for their base types.</p><p><br></p><p><strong>Open-Closed Principle (OCP)</strong></p><p>A class is closed for modifications; but open for extension.</p><p><br></p><p><strong>Interface Segregation Principle (ISP)</strong></p><p>No client class should be forced to depend on methods it does not use.</p><p><br></p><p><strong>Dependency Inversion Principle (DIP)</strong></p><p>High-level modules should not depend on low-level modules. Both should depend upon abstractions.</p><p><br></p><h4>Dependency Inversion Principle (DIP)</h4><p><strong><em>Direct Dependency</em></strong></p><p><strong>Controller (Client)</strong></p><pre class="prettyprint linenums">public class MyController : Controller
{
  private readonly MyService _service;
  public MyController()
  {
    _service = new MyService(); //direct
  }
  public IActionResult ActionMethod()
  {
    _service.ServiceMethod();
  }
}</pre><p><br></p><p><strong>Service (Dependency)</strong></p><pre class="prettyprint linenums">public class MyService
{
  public void ServiceMethod()
  {
    
  }
}</pre><p><br></p><p><strong>Dependency Problem</strong></p><ul><li><p>Higher-level modules depend on lower-level modules.</p></li><li><p>Means, both are tightly-coupled.</p></li><li><p>The developer of higher-level module SHOULD WAIT until the completion of development of lower-level module.</p></li><li><p>Requires much code changes in to interchange an alternative lower-level module.</p></li><li><p>Any changes made in the lower-level module effects changes in the higher-level module.</p></li><li><p>Difficult to test a single module without effecting / testing the other module.</p></li></ul><p><br></p><p><strong>Dependency Inversion Principle</strong></p><ul><li><p>Dependency Inversion Principle (DIP) is a design principle (guideline), which is a solution for the dependency problem.</p></li><li><p>"The higher-level modules (clients) SHOULD NOT depend on low-level modules (dependencies).</p></li><li><p>Both should depend on abstractions (interfaces or abstract class)."</p></li><li><p>"Abstractions should not depend on details (both client and dependency).</p></li><li><p>Details (both client and dependency) should depend on abstractions."</p></li></ul><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-02-833c96a6162932277a2265fa375f5102.png"></figure><p><br></p><p><strong><em>Dependency Injection</em></strong></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-02-35215f40c8089a6e8f64f7477e4040bd.png"></figure><p><br></p><p><strong>Constructor Injection</strong></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-02-b20f1b29ec588cb935c31fa066c1c308.png"></figure><p><br></p><p><strong>Method Injection</strong></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-02-4dc9d013a400ed134c17c731438887a6.png"></figure><p><br></p><p><br></p><p><br></p><h4>Single Responsibility Principle (SRP)</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-02-047638ec4b57608bdeb756a0a2626300.png"></figure><p><br></p><ul><li><p>A class should have one-and-only reason to change.</p></li><li><p>A class should implement only one functionality.</p></li><li><p>Avoid multiple / tightly coupled functionalities in a single class.</p></li><li><p>Eg: A class that performs validation should only involve in validation.</p></li><li><p>But it should not read configuration settings from a configuration file.</p></li><li><p>But instead, it call a method of another class that reads configuration settings.</p></li></ul><p><br></p><p><strong>Interfaces</strong></p><p>Create alternative implementation of the class by implementing the same interface.</p><p>Benefit: Makes the class independent of other classes, in terms of its purpose / functionality.</p><p>So that, the classes become easier to design, write, debug, maintain and test.</p><p><br></p><p>Eg:</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-03-67a0b2456a2d5444189e93e1a52321b3.png"></figure><p><br></p><p><br></p><h4>Interface Segregation Principle (ISP)</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-03-ad4177d49c718ac3e0da1384c9a58fc5.png"></figure><ul><li><p>No client class should be forced to depend on methods it doesn't use.</p></li><li><p>We should prefer to make many smaller interfaces rather than one single big interface.</p></li><li><p>The client classes may choose one or more interfaces to implement.</p></li><li><p>Benefit: Makes it easy to create alternative implementation for a specific functionality, rather than recreating entire class.</p></li></ul><p><br></p><p>Eg:</p><p>Assume, a class has two methods: GetPersons() and AddPerson().</p><p>Instead of creating both methods in a single interface, create them as two different interfaces: IPersonGetter, IPersonAdder</p><ol><li><p>interface IPersonsGetter (methods to get persons data)</p></li><li><p>interface IPersonsAdder(methods to create person)</p></li></ol><p><br></p><p><br></p><h4>Open/Closed Principle (OCP)</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_11-59-03-1244a17a2a361ccb76024d5a18eacc05.png"></figure><p><br></p><p>A class is closed for modifications; but open for extension.</p><p>You should treat each class as readonly for development means; unless for bug-fixing.</p><p>If you want to extend / modify the functionality of an existing class; you need to recreate it as a separate &amp; alternative implementation; rather than modifying existing code of the class.</p><p><br></p><p>Eg:</p><p>Assume, a class has a method: GetPersons().</p><p>The new requirement is to get list of sorted persons.</p><p>Instead of modifying existing GetPersons() method, you need to create an alternative class that gets sorted persons list.</p><p>Benefit: Not modifying existing code of a class doesn't introduce new bugs; and keeps the existing unit tests stay relavant and needs no changes.</p><p><br></p><pre class="prettyprint linenums">class PersonGetter : IPersonGetter (GetPersons() method retrieves list of persons)
class SortedPersonGetter : IPersonGetter (GetPersons() method retrieves sorted list of persons)</pre><p><br></p><p><strong>Interfaces</strong></p><p>Create alternative implementation of the class by implementing the same interface.</p><p><br></p><p><strong>Inheritance</strong></p><p>Create a child class of the existing class and override the required methods that needs changes.</p><p><br></p><p><br></p><p><br></p><h4>Liskov Substitution Principle (LSP)</h4><p><strong>Parent Class</strong></p><pre class="prettyprint linenums">public class ParentClass
{
  public virtual int Calculate(int? a, int? b)
  {
    //if 'a' or 'b' is null, throw ArgumentNullException
    //return sum of 'a' and 'b'
  }
}</pre><p><br></p><p><strong>Child Class</strong></p><pre class="prettyprint linenums">public class ChildClass : ParentClass
{
  public override int Calculate(int? a, int b)
  {
    //if 'a' or 'b' is null, throw ArgumentNullException
    //if 'a' or 'b' is negative, throw ArgumentException
    //return product of 'a' and 'b'
  }
}</pre><p>[Violates LSP]</p><p><br></p><p><br></p><p>Functions that use references of base classes must be able to use objects of derived classes without breaking / changing its functionality.</p><p>The child classes that override methods of base class, should provide same behavior.</p><p><br></p><p><strong>Using object of parent class</strong></p><p>ParentClass variable = new ParentClass();</p><p>variable.Method(); //executes ParentClass.Method</p><p><br></p><p><strong>Using object of child class</strong></p><p>ParentClass variable = new ChildClass();</p><p>variable.Method(); //executes ChildClass.Method</p><p>[Both methods should offer same functionality]</p><p><br></p><p>Functions that use references of base classes must be able to use objects of derived classes without breaking / changing its functionality.</p><p>The child classes that override methods of base class, should provide same behavior.</p><p>If a derived class overrides a method of base class; then the method of derived class should provide same behavior:</p><p>With same input, it should provide same output (return value).</p><p>The child class's method should not introduce (throw) any new exceptions than what were thrown in the base implementation.</p><p>The child class's method should not implement stricter rules than base class's implementation.</p><p><br></p><p><strong>Benefit</strong>: Prevents code to break - if by mistake or wantedly, someone has replaced the derived class with its base class (or even vice versa), as its behavior doesn't change.</p><p><br></p>