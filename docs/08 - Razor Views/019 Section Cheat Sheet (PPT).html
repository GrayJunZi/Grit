<h4>Model-View-Controller (MVC) Pattern</h4><p>"Model-View-Controller" (MVC) is an architectural pattern that separates application code into three main components: Models, Views and Controllers.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_06-53-33-fb1842d2d423c4c84ba55a54fdecb5df.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-11-25_15-00-26-712b2d81ddc50c0471dd09b077c83b5c.png"></figure><p><br></p><ol><li><p>Controller invokes Business Model.</p></li><li><p>Controller creates object of View Model.</p></li><li><p>Controller invokes View.</p></li><li><p>View accesses View Model.</p><p><br></p></li></ol><h4>Responsibilities of Model-View-Controller</h4><p><strong>Controller</strong></p><ul><li><p>Receives HTTP&nbsp;request data.</p></li><li><p>Invoke business model to execute business logic.</p></li></ul><p><br></p><p><strong>Business Model</strong></p><ul><li><p>Receives input data from the controller.</p></li><li><p>Performs business operations such as retrieving / inserting data from database.</p></li><li><p>Sends data of the database back to the controller.</p></li></ul><p><br></p><p><strong>Controller</strong></p><ul><li><p>Creates object of ViewModel and files data into its properties.</p></li><li><p>Selects a view &amp;&nbsp;invokes it &amp;&nbsp;also passes the object of ViewModel to the view.</p></li></ul><p><br></p><p><strong>View</strong></p><ul><li><p>Receives the object of ViewModel from the controller.</p></li><li><p>Accesses properties of ViewModel to render data in html code.</p></li><li><p>After the view renders, the rendered view result will be sent as response.</p></li></ul><p><br></p><h4>Benefits / Goals of MVC architectural pattern</h4><ul><li><p>Clean separation of concerns</p></li><li><p>Each component (model, view and controller) performs single responsibility.</p></li><li><p>Identifying and fixing errors will be easy.</p></li><li><p>Each component (model, view and controller) can be developed independently.</p></li><li><p>In practical, both view and controller depend on the model.</p></li></ul><ul><li><p>Model doesn't depend on neither view nor the controller.</p></li><li><p>This is one of the key benefits of the 'clean separation'.</p></li><li><p>This separation allows the model to be built and tested independently.</p></li><li><p>Unit testing each individual component is easier.</p></li></ul><p><br></p><p><br></p><h4>Views</h4><p>View is a web page (.cshtml) that is responsible for containing presentation logic that merges data along with static design code (HTML).</p><p><br></p><ul><li><p>Controller creates an object of ViewModel and fills data in its properties.</p></li><li><p>Controller selects an appropriate view and invokes the same view &amp;&nbsp;supplies object of ViewModel to the View.</p></li><li><p>View access the ViewModel.</p></li></ul><p><br></p><figure><img height="398" src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-11-25_15-00-27-7ebd13f6500ab2958ca022e0f4af7e04.png" width="651"></figure><p><br></p><ul><li><p>View contains HTML markup with Razor markup (C# code in view to render dynamic content).</p></li><li><p>Razor is the view engine that defines syntax to write C# code in the view. @ is the syntax of Razor syntax.</p></li><li><p>View is NOT supposed to have lots of C# code. Any code written in the view should relate to presenting the content (presentation logic).</p></li><li><p>View should neither directly call the business model, nor call the controller's action methods. But it can send requests to controllers.</p></li></ul><p><br></p><h4>Razor View Engine</h4><p><strong>Razor Code Block</strong></p><pre class="prettyprint linenums">@{

  C# / html code here

}</pre><p>Razor code block is a C# code block that contains one or more lines of C# code that can contain any statements and local functions.</p><p><br></p><p><strong>Razor Expressions</strong></p><pre class="prettyprint linenums">@Expression
--or--
@(Expression)</pre><p>Razor expression is a C# expression (accessing a field, property or method call) that returns a value.</p><p><br></p><p><strong>Razor - If</strong></p><pre class="prettyprint linenums">@if (condition) {
  C# / html code here
}</pre><p><br></p><p><strong>Razor - ifelse</strong></p><pre class="prettyprint linenums">@if (condition) {
  C# / html code here
}
else {
  C# / html code here
}</pre><p>Elseif and nested-if also supported.</p><p><br></p><p><strong>Razor - Switch</strong></p><pre class="prettyprint linenums">@switch (variable) {
  case value1: C# / html code here; break;
  case value2: C# / html code here; break;
  default: C# / html code here; break;
}</pre><p><br></p><p><strong>Razor - foreach</strong></p><pre class="prettyprint linenums">@foreach (var variable in collection ) {
  C# / html code here
}</pre><p><br></p><p><strong>Razor - for</strong></p><pre class="prettyprint linenums">@for (initialization; condition; iteration) {
  C# / html code here
}</pre><p><br></p><p><strong>Razor - Literal</strong></p><pre class="prettyprint linenums">@{
 @: static text
}</pre><p><br></p><p><strong>Razor - Literal</strong></p><p><code>&lt;text&gt;static text&lt;/text&gt;</code></p><p><br></p><p><strong>Razor - Local Functions</strong></p><pre class="prettyprint linenums">@{
return_type method_name(arguments) {
  C# / html code here
 }
}</pre><p><br></p><p>The local functions are callable within the same view.</p><p>Razor - Members</p><p><strong>Razor - Methods, Properties, Fields</strong></p><pre class="prettyprint linenums">@functions {
 return_type method_name(arguments) {
   C# / html code here
 }

 data_type field_name;

 data_type property_name
 {
   set {  }
   get {  }
 }
}</pre><p>The members of razor view can be accessible within the same view.</p><p><br></p><p><strong>Html.Raw( )</strong></p><pre class="prettyprint linenums">@{
 string variable = "html code";
}

@Html.Raw(variable) //prints the html markup without encoding (converting html tags into plain text)</pre><p><br></p><p><br></p><h4>ViewData</h4><p>ViewData is a dictionary object that is automatically created up on receiving a request and will be automatically deleted before sending response to the client.</p><p>It is mainly used to send data from controller to view.</p><figure><img height="334" src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_15-03-09-58e70b16f9eeeac934a0d3be1d91c2b1.png" width="791"></figure><p>ViewData is a property of Microsoft.AspNetCore.Mvc.Controller class and Microsoft.AspNetCore.Mvc.Razor.RazorPage class.</p><p>It is of Microsoft.AspNet.Mvc.ViewFeatures.ViewDataDictionary type.</p><pre class="prettyprint linenums">namespace Microsoft.AspNetCore.Mvc
{
 public abstract class Controller : ControllerBase
 {
   public ViewDataDictionary ViewData { get; set; }
 }
}</pre><p><br></p><ul><li><p>It is derived from IDictionary&lt;KeyValuePair&lt;string, object&gt;&gt; type.</p></li><li><p>That means, it acts as a dictionary of key/value pairs.</p></li><li><p>Key is of string type.</p></li><li><p>Value is of object type.</p></li></ul><p><br></p><p><br></p><h4>ViewData - Properties and Methods</h4><ul><li><p><code>int Count { get; set; }</code> //gets the number of elements.</p></li><li><p><code>[string Key]</code> //Gets or sets an element.</p></li><li><p><code>Add(string key, object value)</code> //Adds a new element.</p></li><li><p><code>ContainsKey(string key)</code> //Determines whether the specified key exists or not.</p></li><li><p><code>Clear()</code> //Clears (removes) all elements.</p></li></ul><p><br></p><p><br></p><h4>ViewBag</h4><p>ViewBag is a property of Controller and View, that is used to access the ViewData easily.</p><p>ViewBag is 'dynamic' type.</p><p><br></p><figure><img height="341" src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_15-03-09-2ee663a389ff31efeace8b99634afcd8.png" width="769"></figure><p><br></p><p>ViewBag is a property of Microsoft.AspNetCore.Mvc.Controller class and Microsoft.AspNetCore.Mvc.Razor.RazorPageBase class.</p><p>It is of dynamic type.</p><pre class="prettyprint linenums">namespace Microsoft.AspNetCore.Mvc
{
 public abstract class Controller : ControllerBase
 {
   public dynamic ViewBag { get; set; }
 }
}</pre><p><br></p><p>The 'dynamic' type similar to 'var' keyword.</p><p>But, it checks the data type and at run time, rather than at compilation time.</p><p>If you try to access a non-existing property in the ViewBag, it returns null.</p><p><code>[string Key] //Gets or sets an element.</code></p><p><br></p><p><br></p><h4>Benefits of 'ViewBag' over ViewData</h4><p>ViewBag's syntax is easier to access its properties than ViewData.</p><p>Eg: <code>ViewBag.property</code> [vs] <code>ViewData["key"]</code></p><p>You need NOT type-cast the values while reading it.</p><p>Eg: <code>ViewBag.object_name.property</code></p><p>[vs]</p><p><code>(ViewData["key"] as ClassName).Property</code></p><p><br></p><p><br></p><h4>Strongly Typed Views</h4><p>Strongly Typed View is a view that is bound to a specified model class.</p><p>It is mainly used to access the model object / model collection easily in the view.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-35-7b763cabc091fd28b3900d0262a9b8ab.png"></figure><p><br></p><h4>Benefits of Strongly Typed Views</h4><ul><li><p>You will get Intellisense while accessing model properties in strongly typed views, since the type of model class was mentioned at @model directive.</p></li><li><p>Property names are compile-time checked; and shown as errors in case of misspelled / non-existing properties in strongly typed views.</p></li><li><p>You will have only one model per one view in strongly typed views.</p></li><li><p>Easy to identify which model is being accessed in the view.</p></li></ul><p><br></p><p><br></p><h4>Helper methods in Controller to invoke a View</h4><ul><li><p><code>return View( ); </code>//View name is the same name as the current action method.</p></li><li><p><code>return View(object Model );</code> //View name is the same name as the current action method &amp; the view can be a strongly-typed view to receive the supplied model object.</p></li><li><p><code>return View(string ViewName);</code> //View name is explicitly specified.</p></li><li><p><code>return View(string ViewName, object Model );</code> //View name is explicitly specified &amp; the view can be a strongly-typed view to receive the supplied model object.</p></li></ul><p><br></p><p><br></p><h4>Strongly Typed Views</h4><p>Strongly Typed View can be bound to a single model directly.</p><p>But that model class can have reference to objects of other model classes.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-35-87da8a57b99e0b938e8d726b6998d0d8.png"></figure><p><br></p><h4>ViewImports.cshtml</h4><p>ViewImports.cshtml is a special file in the "Views" folder or its subfolder, which executes automatically before execution of a view.</p><p>It is mainly used to import common namespaces that are to imported in a view.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-35-329dc5f050480e7ba15f346f40da64ba.png"></figure><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-35-9e45355ee546338d18610fb462da3653.png"></figure><p><br></p><p><br></p><h4>Shared Views</h4><p>Shared views are placed in "Shared" folder in "Views" folder.</p><p>They are accessible from any controller, if the view is NOT present in the "Views\ControllerName" folder.</p><p><br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-36-751fc762b5869c89613f51e5985b114b.png"></figure><p><br></p><p><br></p><h4>View Resolution</h4><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-10-23_17-07-36-cd8e603d3301821aeccd96146003f98a.png"></figure>